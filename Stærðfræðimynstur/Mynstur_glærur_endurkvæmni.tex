\documentclass[handout]{beamer}

\usepackage{Haust2016glærur}

\title{Stærðfræðimynstur í tölvunarfræði}
\subtitle{Vika 6, fyrri fyrirlestur}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\section{Inngangur}

\begin{frame}{Í síðasta tíma}
\begin{itemize}
 \item Þrepun
 \item Sterk þrepun
\end{itemize}
\end{frame}

\section{Rakningarvensl - upprifjun}

\begin{frame}{Rakningarvensl}
\begin{tcolorbox}[title=Rakningarvensl]
Rakningarvensl (e. \emph{recurrence relation}) fyrir runu $\{a_n\}$ er jafna sem skilgreinir $a_n$ sem fall af einum eða fleiri fyrri liðum rununnar, þ.e.a.s. $a_0, a_1, \ldots, a_{n-1}$ fyrir öll $n > n_0$, þar sem $n_0$ er ekki-neikvæð heiltala.
\end{tcolorbox}
Runa er lausn (e. \emph{solution}) á rakningarvenslum ef liðir hennar uppfylla venslin. Liðirnir sem eru fyrir framan fyrsta liðinn sem rankningarvenslin tilgreina eru upphafsskilyrði (e. \emph{initial conditions}) þeirra.
\end{frame}

\begin{frame}{Dæmi um rakningarvensl}
Látum $\{a_n\}$ vera runu sem uppfyllir $a_n = a_{n-1} + 3$ fyrir $n=1, 2, 3, \ldots$ og setjum $a_0 = 2$. Hvað eru þá $a_1, a_2$ og $a_3$? \pause

\begin{align*}
a_1 &= a_0 + 3 = 2 + 3 = 5\\
a_2 &= 5 + 3 = 8\\
a_3 &= 8 + 3 = 11\\
\end{align*}

\end{frame}

\begin{frame}{Dæmi um rakningarvensl}
\begin{itemize}
 \item Fibonacci-rununa $f_0, f_1, f_2, \ldots$ má skilgreina með rakningavenslum
 \begin{itemize}
  \item Upphafsskilyrði: $f_0 = 0, f_1 = 1$
  \item Rakningarvensl: $f_n = f_{n-1} + f_{n-2}$
 \end{itemize}
\end{itemize}
\end{frame}

\section{Endurkvæmni}

\begin{frame}{Endurkvæm lýsing á föllum}
\begin{itemize}
 \item Rakningarvensl eru runur þar sem seinni liðir eru skilgreindir út frá fyrri liðum
 \item Hægt er að nota endurkvæmni (e. \emph{recursion}) til að skilgreina föll út frá sjálfum sér
 \item Endurkvæm skilgreining á falli (með mengi ekki-neikvæðu heiltalnanna sem formengi) fer fram í tvennu lagi:
 \begin{enumerate}
  \item Grunnskref (e. \emph{basis step}) skilgreinir fallsgildi fallsins í núlli eða nálægt núlli
  \item Endurkvæmt skref (e. \emph{recursive step}) gefur reglu til að finna fallsgildi fallsins í gefinni heiltölu með því að nota gildi fallsins af lægri heiltölum
 \end{enumerate}
 \item Endurkvæmni er líka kölluð rakning, endurkvæma skrefið er líka kallað þrepunarskref (e. \emph{inductive step})
\end{itemize}
\end{frame}

\begin{frame}{Endurkvæmt fall}
Við getum skilgreint fall á eftirfarandi hátt:
\begin{align*}
f(0) &= 3\\
f(n+1) &= 2f(n) + 3
\end{align*}
Hvernig finnum við gildi $f(4)$? \pause Finnum öll minni fallsgildi, og reiknum:
\begin{align*}
f(1) = 2f(0) + 3 &= 2 \cdot 3 + 3 = 9\\
f(2) = 2f(1) + 3 &= 2 \cdot 9 + 3 = 21\\
f(3) = 2f(2) + 3 &= 2 \cdot 21 + 3 = 45\\
f(4) = 2f(3) + 3 &= 2 \cdot 45 + 3 = 93
\end{align*}
\end{frame}

\begin{frame}{Endurkvæm skilgreining}
Hvernig getum við á endurkvæman máta skilgreint stærðina $a^n$, þar sem $a$ er rauntala önnur en $0$ og $n$ er jákvæð heiltala?
\pause
\begin{itemize}
 \item Grunnskref: Skilgreinum $a^0 = 1$.
 \item Endurkvæmt skref: $a^{n+1} = a \cdot a^n$
\end{itemize}
\end{frame}

\section{Endurkvæm skilgreining mengja}

\begin{frame}{Endurkvæm skilgreining mengja}
\begin{itemize}
 \item Hægt er að skilgreina mengi á endurkvæman máta 
 \begin{itemize}
  \item Grunnskref: Tilgreinum safn staka sem tilheyrir menginu
  \item Endurkvæmt skref: Tilgreinum reglu til að búa til ný stök út frá upphaflegu stökunum
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Endurkvæm skilgreining}
\begin{itemize}
 \item Skilgreinum $S$, mengi allra jákvæðra margfelda af $3$:
 \begin{itemize}
  \item Grunnskref: $3 \in S$
  \item Endurkvæmt skref: Sé $x \in S$ og $y \in S$, þá er $x+y \in S$
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Upprifjun - Strengir}
\begin{itemize}
 \item Sérstök, mikið notuð gerð af runum kallast strengur (e. \emph{string})
 \item Strengur er endanleg runa af stöfum, úr endanlegu mengi (stafrófinu)
 \begin{itemize}
  \item Stafrófið getur verið hvaða mengi sem er, en algeng stafróf eru \texttt{\{'a', 'b', 'c', \ldots\}} og \texttt{\{0, 1\}}
 \end{itemize}
 \item Strengur með engum stöfum (af lengdinni $0$) er kallaður tómur og táknaður með $\lambda$
\end{itemize}
\end{frame}

\begin{frame}{Strengir - endurkvæm skilgreining}
\begin{itemize}
 \item Við getum skilgreint mengi strengja $\Sigma^*$ yfir stafrófið $\Sigma$ á endurkvæman hátt:
 \begin{itemize}
  \item Grunnskref: $\lambda \in \Sigma^*$
  \item Endurkvæmt Skref: Sé $w \in \Sigma^*$ og $x \in \Sigma$, þá er $wx \in \Sigma^*$
 \end{itemize}
 \item Þ.e.a.s. ef við skeytum staf úr stafrófinu aftan á streng fáum við annan streng
\end{itemize}
\end{frame}

\begin{frame}{Strengjasamskeyting}
\begin{itemize}
 \item Getum skilgreint samskeytingu (e. \emph{concatenation}) tveggja strengja á endurkvæman átt:
 \begin{itemize}
  \item Grunnskref: Sé $w \in \Sigma^*$ er $w\lambda = w$
  \item Endurkvæmt Skref: Sé $w_1 \in \Sigma^*$ og $w_2 \in \Sigma^*$ og $x \in \Sigma$, þá er $w_1(w_2x) = (w_1w_2)x$
 \end{itemize}
 \item Dæmi: Sé $w_1 = abra$ og $w_2 = cadabra$ er $w_1w_2 = abracadabra$.
\end{itemize}
\end{frame}

\begin{frame}{Næst}
Kaflar 5.4 (endurkvæm reiknirit) og 5.5 (sönnun forrita).
\end{frame}


\section{Endurkvæm reiknirit}

\begin{frame}{Endurkvæm reiknirit}
\begin{itemize}
 \item Munum að reiknirit er endanleg runa vel skilgreindra aðgerða sem reikna út lausn á skilgreindu vandamáli
 \item Reiknirit hefur inntak, sem lýsir tilviki af vandamálinu sem það leysir
 \item Reiknirit er kallað endurkvæmt ef það leysir vandamálið með því að smætta það niður í smærra tilvik af sama vandamáli
\end{itemize}
\end{frame}

\begin{frame}{Endurkvæmt hrópmerkt}
Hrópmerkt hentar vel til endurkvæms útreiknings.
\begin{center}
\includegraphics[width=\textwidth]{factorial-algorithm}
\end{center}
\[
3! = 3\cdot 2! = 3 \cdot 2 \cdot 1! = 3 \cdot 2 \cdot 1 \cdot 0! = 3 \cdot 2 \cdot 1 \cdot 1
\]
\end{frame}

\begin{frame}{Endurkvæmt GCD}
\begin{columns}
\column{0.5\textwidth}
Við getum reiknað stærsta samdeili (gcd) með endurkvæmu reikniriti sem byggir á því að 
\[
 gcd(a,b) = gcd(b \Mod a, a)
\]
og að 
\[
 gcd(0,b) = b
\]
þegar $b > 0$.
\column{0.5\textwidth}

\vspace{0.5cm}
Þannig getum við reiknað stærsta samdeili 5 og 8:
\begin{align*}
gcd(5,8) &= gcd(8 \Mod 5, 5)\\
&= gcd(3,5)\\
&= gcd(5 \Mod 3, 3)\\
&= gcd(2,3)\\
&= gcd(3 \Mod 2, 2)\\
&= gcd(1,2)\\
&= gcd(2 \Mod 1, 1)\\
&= gcd(0,1)\\
&= 1
\end{align*}

\end{columns}
\end{frame}

\begin{frame}{Endurkvæmt GCD}
Við getum skrifað reiknirit út frá þessari innsýn:
\begin{center}
\includegraphics[width=\textwidth]{gcd-recursive}
\end{center}
\end{frame}

\begin{frame}{Línuleg leit}
Rifjum upp línulega leit:
\begin{center}
\includegraphics[width=\textwidth]{linear-search}
\end{center}
\end{frame}

\begin{frame}{Endurkvæm línuleg leit?}
Getum við gert endurkvæma útgáfu af línulegri leit?\pause

Já, við getum það:
\begin{center}
\includegraphics[width=\textwidth]{linear-search-recursive}
\end{center}
\end{frame}

\begin{frame}{Helmingunarleit}
Rifjum upp helmingunarleit:
\begin{center}
\includegraphics[width=\textwidth]{binary-search}
\end{center}
\end{frame}

\begin{frame}{Endurkvæm helmingunarleit?}
Getum við gert endurkvæma útgáfu af helmingunarleit?\pause

Já, við getum það:
\begin{center}
\includegraphics[width=0.8\textwidth]{binary-search-recursive}
\end{center}
\end{frame}

\section{Endurkvæmni og ítrun}

\begin{frame}{Endurkvæmni og ítrun}
\begin{itemize}
 \item Höfum séð endurkvæm reiknirit sem byrja á að skoða heildarmyndina og brjóta hana svo niður í smærri tilvik
 \item Gætum þess í stað séð fyrir okkur að við byrjum á að skoða smáu tilvikin og ``byggjum svo upp'' í þau stóru
 \begin{itemize}
  \item Slíka aðferðafræði köllum við ítrun
  \item Ítrun er venjulega framkvæmd með lykkjum
 \end{itemize}
 \item Ítrun og endurkvæmni framkvæma hliðstæða útreikninga!
\end{itemize}
\end{frame}

\begin{frame}{Endurkvæmni og ítrun}
\begin{itemize}
 \item Hvenær á að nota endurkvæmni og hvenær á að nota ítrun við forritun? \pause
 \begin{itemize}
  \item Ráðlegging undirritaðs: Notið það sem ykkur finnst lýsa vandamálinu best
  \begin{itemize}
   \item Tími forritarans er verðmætur
   \item Getið síðan breytt úr einu í annað ef \emph{mælingar} sýna að upprunalega nálgunin er ekki skilvirk
  \end{itemize}
  \item Þekkið forritunarmálin sem þið eruð að nota - styðja þau endurkvæmni vel?
 \end{itemize}
\end{itemize}
\end{frame}

\section{Merge Sort}

\begin{frame}{Röðun}
\begin{itemize}
 \item Höfum áður séð innsetningarröðun
 \begin{itemize}
  \item Keyrslutími innsetningarröðunar á runu af lengd $n$ er $O(n^2)$ í versta tilfellinu
 \end{itemize}
 \item Skoðum nú endurkvæma lýsingu á reikniriti sem raðar á $O(n\log(n))$ tíma í versta tilfellinu
\end{itemize}
\end{frame}

\begin{frame}{Merge sort}
\begin{itemize}
 \item Hugmyndin að baki merge sort er eftirfarandi:
 \begin{itemize}
  \item Heildarrununni er skipt upp í tvær hlutrunur af jafnri (eða næstum jafnri) lengd
  \begin{itemize}
   \item Hverri hlutrunu er svo skipt upp í tvær hluthlutrunur, o.s.frv.
   \item Uppskiptingunni er haldið áfram þar til runurnar eru af lengdinni 1
  \end{itemize}
  \item Þegar uppskiptingunni er lokið eru runurnar sameinaðar tvær og tvær svo að úr verði röðuð runa
  \begin{itemize}
   \item Þegar síðustu sameiningunni er lokið er runan röðuð!
  \end{itemize}
  \item Merge sort var fundið upp af John von Neumann (1945)
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Keyrsla merge sort}
\vspace{0.5cm}
\begin{center}
\includegraphics[width=0.5\textwidth]{merge-sort-visual}
\end{center}
\end{frame}

\begin{frame}{Merge reikniritið}
Mikið af vinnunni sem fer fram í merge sort felst í því að sameina listana:
\begin{center}
\includegraphics[width=\textwidth]{merge}
\end{center}
\end{frame}

\begin{frame}{Merge sort}
Merge sort er síðan lýst endurkvæmt:
\begin{center}
\includegraphics[width=0.9\textwidth]{merge-sort}
\end{center}
\end{frame}

\section{Rökstudd forritun}

\begin{frame}{Rökstudd forritun}
\begin{itemize}
 \item Bókin inniheldur vísi að umfjöllun um rökstudda forritun
 \item Sýnir að hægt er að tengja saman rökfræði og reiknirit
\end{itemize}
\end{frame}

\begin{frame}{Hugtök úr rökstuddri forritun}
\begin{itemize}
 \item Forrit er naumrétt (e. \emph{partially correct} eða \emph{weakly correct}) skili það ``réttri niðurstöðu'' þegar forritið er ``rétt notað'' og lýkur keyrslu
 \item Til skilgreiningar á því hvað teljist rétt eru hugtökin forskilyrði (e. \emph{precondition} eða \emph{initial assertion}) og eftirskilyrði (e. \emph{postcondition} eða \emph{final assertion}) notuð
 \begin{itemize}
  \item Forskilyrði lýsa þeim aðstæðum sem þurfa að gilda áður en forrit keyrir (venjulega lýsing eiginleikum inntaks)
  \item Eftirskilyrði lýsir þeim aðstæðum sem gilda eftir að forrit keyrir (venjulega lýsing á eiginleikum skilagildis)
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Naumrétt forrit}
\begin{tcolorbox}[title=Naumrétt forrit]
Forrit eða forritsbútur $S$ er naumréttur með tilliti til forskilyrðisins $p$ og eftirskilyrðisins $q$ ef $q$ er satt hvenær sem $p$ er satt og $S$ lýkur keyrslu.

Rithátturinn $p\{S\}q$ táknar að $S$ sé naumrétt með tilliti til forskilyrðisins $p$ og eftirskilyrðisins $q$.
\end{tcolorbox}
Sé forrit naumrétt m.t.t. gefinna skilyrða og auk þess er tryggt að það ljúki alltaf keyrslu við gefin skilyrði er það rammrétt (e. \emph{correct} eða \emph{strongly correct}).

Rithátturinn $p\{S\}q$ er kallaður Hoare þrennd (e. \emph{Hoare triple}).
\end{frame}

\begin{frame}{Rökstutt forrit}
Sýnum að forritsbúturinn
\begin{align*}
y &:= 2\\
z &:= x + y
\end{align*}
sé naumréttur m.t.t. upphafsskilyrðisins $p: x = 1$ og eftirskilyrðisins $q: z = 3$. \pause

G.r.f.a. $p$ sé satt. $y$ fær gildið 2. Þar sem $p$ er satt fær $z$ gildið $1+2 = 3$. Þá er $q$ satt, svo $p\{S\}q$ er satt.
\end{frame}

\begin{frame}{Lengri rökstudd forrit}
\begin{itemize}
 \item Við getum rökstutt lengri forrit með því að brjóta þau niður í rökstudda forritsbúta
 \item Við getum skilgreint leiðir til að rökstyðja forritsbúta sem fela í sér algeng forritunarhugtök:
 \begin{itemize}
  \item Lykkjur
  \item Stýrisetningar
 \end{itemize}
 \item Gildi, fyrir gefna forritsbúta $S_1$ og $S_1$ bæði $p\{S_1\}q$ og $q\{s_2\}r$, þá má fyrir samsetta forritið $S = S_1;S_2$ skrifa $p\{S_1; S_2\}r$ eða einfaldlega $p\{S\}r$
\end{itemize}
\end{frame}

\end{document}
